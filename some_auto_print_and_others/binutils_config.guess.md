- 脚本的功能：输出运行该脚本的系统的配置名称。
- 禁用 SC2006 和 SC2268 这两个规则
```bash
#! /bin/sh
# Attempt to guess a canonical system name.
#   Copyright 1992-2023 Free Software Foundation, Inc.

# shellcheck disable=SC2006,SC2268 # see below for rationale

# 脚本最后一次修改的日期
timestamp='2023-08-22'

# This file is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <https://www.gnu.org/licenses/>.
#
# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that
# program.  This Exception is an additional permission under section 7
# of the GNU General Public License, version 3 ("GPLv3").
#
# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
#
# You can get the latest version of this script from:
# https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
#
# Please send patches to <config-patches@gnu.org>.


# The "shellcheck disable" line above the timestamp inhibits complaints
# about features and limitations of the classic Bourne shell that were
# superseded or lifted in POSIX.  However, this script identifies a wide
# variety of pre-POSIX systems that do not have POSIX shells at all, and
# even some reasonably current systems (Solaris 10 as case-in-point) still
# have a pre-POSIX /bin/sh.

# $0：是一个特殊的 Shell 变量，它存储了正在执行的脚本的文件名
# s,.*/,,' 表示将字符串中最后一个斜杠 "/" 及其前面的所有字符替换为空字符串
# me = "config.guess",me就是文件名
me=`echo "$0" | sed -e 's,.*/,,'`

# 脚本的用法信息，`\` 符号用来在多行字符串中保持格式。
usage="\
Usage: $0 [OPTION]
# 输出运行该脚本的系统的配置名称
Output the configuration name of the system '$me' is run on.

Options:
  -h, --help         print this help, then exit
  -t, --time-stamp   print date of last modification, then exit
  -v, --version      print version number, then exit

Report bugs and patches to <config-patches@gnu.org>."


# 脚本的功能：输出运行该脚本的系统的配置名称。
version="\
# 脚本的名称和版本
GNU config.guess ($timestamp)

# 作者信息和版权信息
Originally written by Per Bothner.
Copyright 1992-2023 Free Software Foundation, Inc.

This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."

# 提示用户可以使用 $me --help 命令查看更多信息。$me 会被替换成脚本文件名
help="
Try '$me --help' for more information."


# 解析脚本的命令行参数，并根据参数执行相应的操作
# **循环解析参数**
# Parse command line
while test $# -gt 0 ; do
  case $1 in
	  # 打印 `$timestamp` 变量的值 (即脚本最后修改日期) 并退出脚本
    --time-stamp | --time* | -t )
       echo "$timestamp" ; exit ;;
    --version | -v )
       echo "$version" ; exit ;;
    --help | --h* | -h )
       echo "$usage"; exit ;;
       # 如果第一个参数是 `--`，则表示停止处理选项，后面的参数将被视为普通参数。`shift` 命令会将所有参数左移一位，即 `$2` 变成 `$1`，`$3` 变成 `$2`，以此类推。
       # 在 `--` 之后的参数都会被视为普通参数，即使它们以 `-` 开头
    -- )     # Stop option processing
       shift; break ;;
       # 如果第一个参数是 `-`，则表示从标准输入读取数据。
       # - 在这段代码中，如果遇到 `-` 选项，就会执行 `break;` 命令，跳出 `case` 语句，继续执行 `while` 循环后面的代码。此时，脚本会认为用户希望从标准输入读取数据，而不是传递命令行参数。
    - )	# Use stdin as input.
       break ;;
       # 如果第一个参数以 `-` 开头，但不匹配以上任何一种情况，则认为这是一个无效选项。脚本会打印错误信息 (包括脚本名、无效选项和帮助信息) 并退出，退出状态码为 1 (表示出错)。
    -* )
       echo "$me: invalid option $1$help" >&2
       exit 1 ;;
       # 如果第一个参数不匹配以上任何一种情况 (通常表示这是一个普通参数)，则跳出 `case` 语句
    * )
       break ;;
  esac
done

# 循环结束后，如果 `$#` 不等于 0 (即还有剩余参数)，则说明用户传递了过多的参数。
if test $# != 0; then
  echo "$me: too many arguments$help" >&2
  exit 1
fi

# Just in case it came from the environment.
# 定义 `GUESS` 变量的目的是为了防止它被环境变量覆盖，确保其初始为空。
GUESS=

#- `CC_FOR_BUILD` 存储了脚本用于系统检测的编译器名称。
# - 但是，使用编译器进行系统检测并不推荐，因为它需要创建临时文件，并且难以保证跨平台的兼容性。
# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
# compiler to aid in system detection is discouraged as it requires
# temporary files to be created and, as you can see below, it is a
# headache to deal with in a portable fashion.

# Historically, 'CC_FOR_BUILD' used to be named 'HOST_CC'. We still
# use 'HOST_CC' if defined, but it is deprecated.

# Portable tmp directory creation inspired by the Autoconf team.
# **创建临时目录**
# 创建临时目录的方法参考了 Autoconf 工具的实现
tmp=
# shellcheck disable=SC2172
# 设置了一个 shell 陷阱 (trap)，当脚本退出 (exit)、收到信号 1 (HUP)、2 (INT)、13 (PIPE) 或 15 (TERM) 时，会执行后面的命令，该命令会检查 `$tmp` 是否为空，如果不为空，则删除 `$tmp` 目录及其内容。 这段代码的作用是在脚本结束后自动清理临时目录。
trap 'test -z "$tmp" || rm -fr "$tmp"' 0 1 2 13 15

# 这个函数的作用是设置 `CC_FOR_BUILD` 变量的值，也就是找到一个可用的 C 编译器
# 生成随机的目录名，并设置合适的权限，有效降低安全风险
set_cc_for_build() {
    # prevent multiple calls if $tmp is already set
    # 如果 `$tmp` 变量不为空，说明已经创建过临时目录，函数直接返回 0，避免重复操作。
    test "$tmp" && return 0
    # 如果环境变量 `TMPDIR` 没有定义，则将其设置为 `/tmp`。
    : "${TMPDIR=/tmp}"
    # shellcheck disable=SC2039,SC3028

	# 接下来的代码块尝试在 `$TMPDIR` 目录下创建临时目录，用于存放编译过程中产生的临时文件。
	# 首先尝试使用 `mktemp` 命令创建以 "cg" 开头的随机目录
	# 如果失败，则尝试在 `$TMPDIR` 下创建以 "cg" 开头，后面跟着进程 ID 和随机数的目录
	# 如果仍然失败，则尝试创建以 "cg-" 开头，后面跟着进程 ID 的目录，并打印警告信息，提示创建的目录可能不安全。（攻击者可以在脚本创建目录和脚本使用目录之间的时间差内，创建一个同名目录并植入恶意文件。由于 PID 是可以预测的，攻击者可以预先创建好目录，等待脚本使用。）
	# 如果所有尝试都失败，则打印错误信息并退出脚本。
	# tmp=$TMPDIR/cg.../=/tmp/cg.../
    { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
	{ echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; }


	# 在临时目录下创建一个名为 `dummy` 的文件
    dummy=$tmp/dummy
    # 根据 `CC_FOR_BUILD`, `HOST_CC`, `CC` 这三个变量的值，选择不同的方式设置 `CC_FOR_BUILD`
    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in
    # 如果都没有定义，则依次尝试使用 `cc`, `gcc`, `c89`, `c99` 编译器，如果某个编译器可以成功编译一个简单的 C 程序 (`int x;`)，则将 `CC_FOR_BUILD` 设置为该编译器。如果都没有找到，则将 `CC_FOR_BUILD` 设置为 `no_compiler_found`。
	# 顺序问题：
		# **`HOST_CC` (最高优先级):** `HOST_CC` 是一个专门用于指定交叉编译环境下主机编译器的变量。 如果定义了 `HOST_CC` ，说明用户明确指定了要使用的编译器，因此脚本会优先使用 `HOST_CC` 的值。
		# **`CC` (次优先级):** `CC` 是一个常用的环境变量，用于指定默认的 C 编译器。如果 `HOST_CC` 没有定义，但 `CC` 定义了，脚本会使用 `CC` 的值作为编译器。
		# **自动探测 (最低优先级):** 如果 `HOST_CC` 和 `CC` 都没有定义，脚本会尝试自动探测可用的编译器。它会依次测试 `cc`、`gcc`、`c89`、`c99` 这几个常见的编译器，如果某个编译器能够成功编译测试代码 (`int x;`)，就将该编译器的名称赋给 `CC_FOR_BUILD`。
	,,)    echo "int x;" > "$dummy.c"
	# 顺序问题：
	    # - **cc:** 在很多 Unix-like 系统上， `cc` 是系统默认的 C 编译器命令。它通常是指向系统实际使用的 C 编译器 (比如 GCC) 的符号链接。将 `cc` 放在第一个尝试，是为了兼容那些使用 `cc` 作为默认 C 编译器命令的系统。
	    # - **gcc:** GCC (GNU Compiler Collection) 是一款非常流行的开源 C 编译器，它被广泛应用于各种 Unix-like 系统。由于 GCC 的流行，将其放在第二位尝试也是很合理的。
	       for driver in cc gcc c89 c99 ; do
	       # 依次通过名字来调用编译器，找到一个可用的
	       # “>/dev/null 2>&1”，重定向操作：第一个将标准输出重定向到/dev/null丢弃输出，第二个是将标准错误输出重定向到标准输出也就是“/dev/null”，这是文件描述符的复制，并不是取址操作
		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
		       CC_FOR_BUILD=$driver
		       break
		   fi
	       done
		   # 检查 CC_FOR_BUILD 变量是否为空，这里的x可以换成任意，比如y也可以，只是为了保证语法不出错误，因为“test "$CC_FOR_BUILD" = ”的语法是违法的，同时“test "$CC_FOR_BUILD" = ""”这种写法在bash中可行，但是在一些旧版本的 Shell 中，直接将空字符串放在 `test` 命令的参数位置可能会导致语法错误。
	       if test x"$CC_FOR_BUILD" = x ; then
		   CC_FOR_BUILD=no_compiler_found
	       fi
	       ;;
	# ,,*): 如果只有 CC 定义了，则将 CC_FOR_BUILD 设置为 CC 的值。
	,,*)   CC_FOR_BUILD=$CC ;;
	# - `,*,*)`: 如果 `HOST_CC` 定义了，则将 `CC_FOR_BUILD` 设置为 `HOST_CC` 的值。
	,*,*)  CC_FOR_BUILD=$HOST_CC ;;
    esac
}# the set_cc_for_build() end

# 在 Pyramid OSx 系统上，当运行在 BSD 环境下时，需要这段代码才能找到 `uname` 命令。
# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
# (ghazi@noc.rutgers.edu 1994-08-24)
if test -f /.attbin/uname ; then
	PATH=$PATH:/.attbin ; export PATH
fi

# 获取系统的硬件架构（`将` uname -m` 命令的标准输出 (stdout) 作为命令替换的结果，丢弃标准错误输出），如果命令执行失败 (退出状态码非 0)，则将 `UNAME_MACHINE` 设置为 `unknown`。
# 一般的三元组：MACHINE-VERSION-SYSTEM-RELEASE，如x86_64-lfs-linux-gnu
UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown

# 当检测到系统是 Linux/GNU 时，尝试识别系统使用的 C 标准库 (libc)，例如 glibc、musl libc 等，并将识别结果存储到 LIBC 变量中。
case $UNAME_SYSTEM in
Linux|GNU|GNU/*)
	# **`LIBC=unknown`**: 将 `LIBC` 变量的初始值设置为 `unknown`，表示尚未识别出 C 标准库
	LIBC=unknown

	# 调用前面定义的 `set_cc_for_build` 函数，尝试找到一个可用的 C 编译器。
	set_cc_for_build
	# 使用 `cat` 命令和 `EOF` 标记创建了一个名为 `$dummy.c` 的临时文件，并将一段 C 代码写入该文件，这段 C 代码的作用是根据预定义的宏来判断系统使用的 C 标准库。
	# 写入的C代码的逻辑：(不同的C标准库在功能、API、性能和资源占用、ABI（程序二进制接口）兼容性等方面有差异)
		# 如果定义了 __ANDROID__ 宏，则说明是 Android 系统，LIBC 被设置为 android。
		# 否则，会包含 `<features.h>` 头文件，并根据以下宏进行判断：
			# __UCLIBC__：uClibc C 标准库，LIBC 设置为 uclibc。
			#__dietlibc__：dietlibc C 标准库，LIBC 设置为 dietlibc。
			# __GLIBC__：glibc C 标准库，LIBC 设置为 gnu。
		# 顺序问题：（整体是从特殊到一般的顺序，中间三个也差不多是这个顺序）
			# __ANDROID__ 宏是 Android 平台特有的，因此放在最前面判断
			# <features.h> 头文件定义了一些与系统特性相关的宏，这些宏可能被多个 C 标准库定义，例如 __UCLIBC__、__dietlibc__ 和 __GLIBC__ 等。因此，在判断这些宏之前，需要先包含 <features.h> 头文件。
			# __DEFINED_va_list 宏是 musl libc 特有的，因此放在最后判断。如果前面的判断都没有确定 C 标准库，则可以尝试使用这个宏来判断是否使用了 musl libc。
	cat \<<-EOF > "$dummy.c"
	# 这是一个条件编译指令，如果定义了 __ANDROID__ 预处理器宏，则执行下面的代码块。
	#if defined(__ANDROID__)   //1
	LIBC=android
	#else   //1
	#include <features.h>
	#if defined(__UCLIBC__)   //2
	LIBC=uclibc
	#elif defined(__dietlibc__)
	LIBC=dietlibc
	#elif defined(__GLIBC__)
	LIBC=gnu
	#else    //2
	#include <stdarg.h>
	/* First heuristic to detect musl libc.  */
	#ifdef __DEFINED_va_list    //3
	LIBC=musl
	#endif
	#endif
	#endif
	EOF
	# 这段代码使用找到的 C 编译器 (`$CC_FOR_BUILD`) 预处理 `$dummy.c` 文件，然后使用 `grep` 正则表达匹配以 "LIBC" 开头的行，`sed` 命令处理所有输出空格，提取出 `LIBC` 变量的值，最后将结果存储到 `cc_set_libc` 变量中
	# cc_set_libc="LIBC=gnu",cc_set_libc是string类型
	# -E: 这是一个编译器选项，告诉编译器只进行预处理，而不进行编译、汇编和链接。
		# "只进行预处理"指的是在编译 C/C++ 代码的过程中，只执行预处理器指令，而不进行后续的编译、汇编和链接操作。
		# - 将 `dummy.c` 文件中的预处理器宏展开，根据不同的系统环境生成不同的 `LIBC` 变量定义。
	cc_set_libc=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
	# 使用 `eval` 命令执行 `cc_set_libc` 变量中存储的命令，这会将 `LIBC` 变量的值更新为 C 代码中识别出的结果。
	#LIBC=gnu （maybe）
	eval "$cc_set_libc"

	# 如果 LIBC 仍然是 unknown，并且系统中存在 ldd 命令，则使用 ldd --version 命令检查是否使用了 musl libc。如果使用了，则将 LIBC 设置为 musl。
	# Second heuristic to detect musl libc.
	if [ "$LIBC" = unknown ] &&
	   command -v ldd >/dev/null &&
	   ldd --version 2>&1 | grep -q ^musl; then
		LIBC=musl
	fi

	# 如果 LIBC 仍然是 unknown (例如系统缺少编译器)，则默认使用 glibc (GNU C 标准库)，将 LIBC 设置为 gnu。
	# If the system lacks a compiler, then just pick glibc.
	# We could probably try harder.
	if [ "$LIBC" = unknown ]; then
		LIBC=gnu
	fi
	;;
esac

# Note: order is significant - the case branches are not exclusive.

case $UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION in
	# 如果是NetBSD系统
	# NetBSD系统指的内核是NetBSD，与linux无交叉，都是unixlike内核
    *:NetBSD:*:*)
	# NetBSD (nbsd) targets should (where applicable) match one or
	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
	# switched to ELF, *-*-netbsd* would select the old
	# object file format.  This provides both forward
	# compatibility and a consistent mechanism for selecting the
	# object file format.
	#
	# NetBSD不关心厂商，所以厂商一律是unknown
	# Note: NetBSD doesn't particularly care about the vendor
	# portion of the name.  We always set it to "unknown".
	# 获取硬件架构
	# UNAME_MACHINE_ARCH=x86_64   OR aarch64(也就是arm架构，从armV8中独立出来的)
	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
	    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \
	    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \
	    echo unknown)`
	# 设置 machine 变量：machine=architecture-unknown（x86_64-unknown）
	# 很奇怪的是，它并没有去匹配x86_64或AMD64,可能是x86_64不需要特殊配置吧
	case $UNAME_MACHINE_ARCH in
	    aarch64eb) machine=aarch64_be-unknown ;;
	    armeb) machine=armeb-unknown ;;
	    arm*) machine=arm-unknown ;;
	    sh3el) machine=shl-unknown ;;
	    sh3eb) machine=sh-unknown ;;
	    sh5el) machine=sh5le-unknown ;;
	    earmv*)
		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
		machine=${arch}${endian}-unknown
		;;
	    *) machine=$UNAME_MACHINE_ARCH-unknown ;;
	esac
	# 设置 os 变量， os 变量表示操作系统的类型，包括目标文件格式和 ABI 等信息。
	# The Operating System including object format, if it has switched
	# to ELF recently (or will in the future) and ABI.
	# os=netbsd
	case $UNAME_MACHINE_ARCH in
	    earm*)
		os=netbsdelf
		;;
	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
		set_cc_for_build
		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
			| grep -q __ELF__
		then
		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
		    # Return netbsd for either.  FIX?
		    os=netbsd
		else
		    os=netbsdelf
		fi
		;;
	    *)
		os=netbsd
		;;
	esac
	# 设置 abi 变量
	# 对于使用 ELF 格式的 NetBSD 系统 (netbsdelf)，ABI 信息通常已经包含在目标文件中了，所以不需要额外的 ABI 标识
	# Determine ABI tags.
	case $UNAME_MACHINE_ARCH in
	    earm*)
		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
		;;
	esac
	# The OS release
	# Debian GNU/NetBSD machines have a different userland, and
	# thus, need a distinct triplet. However, they do not need
	# kernel version information, so it can be replaced with a
	# suitable tag, in the style of linux-gnu.
	# 设置 release 变量，根据 `$UNAME_VERSION` 的值设置 `release` 变量，`release` 变量表示操作系统的版本信息。
	# 对于 Debian GNU/NetBSD 系统， `release` 设置为 `-gnu`
	# 对于其他 NetBSD 系统，会使用 sed 和 cut 命令提取版本号的前两部分。
	# Debian和NetBSD是两个独立开发的系统，这里引出一个疑问，明明是在处理NetBSD，跟Debian有什么关系？
		# 因为Debian 项目维护着一个名为 Debian GNU/NetBSD 的移植版本将 Debian 的用户空间和软件包管理系统移植到了 NetBSD 内核之上。这段代码的目的是为了更准确地识别 Debian GNU/NetBSD 系统，并生成正确的系统配置名称。
		# 关于Debian GNU/NetBSD：Debian GNU/NetBSD 是一个将 Debian GNU/Linux 发行版移植到 NetBSD 内核上的项目。这意味着它结合了 Debian 用户空间（包括其庞大的软件包库和易于使用的 apt 软件包管理器）和 NetBSD 内核（以其可移植性和代码质量而闻名）。
		# Debian 用户空间: 使用 Debian 的软件包库和 apt 包管理器，可以轻松安装和管理软件。
		# NetBSD 内核: 利用 NetBSD 内核的可移植性，可以在更广泛的硬件平台上运行 Debian 系统。
		# 混合优势: 结合 Debian 易用性和 NetBSD 稳定性，为用户提供独特的体验。
	case $UNAME_VERSION in
	    Debian*)
		release='-gnu'
		;;
	    *)
		release=`echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2`
		;;
	esac
	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
	# contains redundant information, the shorter form:
	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
	# 假设我现在的系统是Debian GNU/NetBSD，我得到的应该是
	# GUESS=x86_64-unknown-netbsd-gnu
	GUESS=$machine-${os}${release}${abi-}
	;;    # THE NetBSD END


	# 处理 `$UNAME_SYSTEM` 变量值为 `Bitrig` 的情况，作用是识别 Bitrig 操作系统并设置相应的系统配置名称。
    *:Bitrig:*:*)
	# arch 命令会输出系统的处理器架构信息，例如 amd64, i386 等
	# UNAME_MACHINE_ARCH 变量会存储处理后的处理器架构信息，例如 amd64。
	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
	# 例如，如果 UNAME_MACHINE_ARCH 是 amd64， UNAME_RELEASE 是 7.2，则 GUESS 会被设置为 amd64-unknown-bitrig7.2。
	GUESS=$UNAME_MACHINE_ARCH-unknown-bitrig$UNAME_RELEASE
	;;
	# 以上处理的是只匹配system或者说kernel的情况
	# $UNAME_VERSION 变量并未在这个条件中直接涉及，匹配到任意值。
    mips:OSF1:*.*)
	GUESS=mips-dec-osf1
	;;
	# 在 Alpha 架构、OSF1 操作系统的机器上，通过 sizer 和 psrinfo 命令获取系统版本和 CPU 类型信息，最终组合生成一个系统描述字符串 GUESS
    alpha:OSF1:*:*)
    # 在一些 Alpha/OSF1 系统版本中， /usr/sbin/sizer -v 命令在执行完后，可能会返回一个非零的退出代码，即使它成功获取了系统版本信息。
	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
	trap '' 0
	case $UNAME_RELEASE in
	*4.0)
		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
		;;
	*5.*)
		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
		;;
	esac
	# According to Compaq, /usr/sbin/psrinfo has been available on
	# OSF/1 and Tru64 systems produced since 1995.  I hope that
	# covers most systems running today.  This code pipes the CPU
	# types through head -n 1, so we only detect the type of CPU 0.
	# 使用 /usr/sbin/psrinfo -v 命令获取 CPU 信息
	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
	# 根据获取到的 CPU 类型，将 UNAME_MACHINE 变量设置为对应的值，例如 alphaev5, alphapca56 等。
	case $ALPHA_CPU_TYPE in
	    "EV4 (21064)")
		UNAME_MACHINE=alpha ;;
	    "EV4.5 (21064)")
		UNAME_MACHINE=alpha ;;
	    "LCA4 (21066/21068)")
		UNAME_MACHINE=alpha ;;
	    "EV5 (21164)")
		UNAME_MACHINE=alphaev5 ;;
	    "EV5.6 (21164A)")
		UNAME_MACHINE=alphaev56 ;;
	    "EV5.6 (21164PC)")
		UNAME_MACHINE=alphapca56 ;;
	    "EV5.7 (21164PC)")
		UNAME_MACHINE=alphapca57 ;;
	    "EV6 (21264)")
		UNAME_MACHINE=alphaev6 ;;
	    "EV6.7 (21264A)")
		UNAME_MACHINE=alphaev67 ;;
	    "EV6.8CB (21264C)")
		UNAME_MACHINE=alphaev68 ;;
	    "EV6.8AL (21264B)")
		UNAME_MACHINE=alphaev68 ;;
	    "EV6.8CX (21264D)")
		UNAME_MACHINE=alphaev68 ;;
	    "EV6.9A (21264/EV69A)")
		UNAME_MACHINE=alphaev69 ;;
	    "EV7 (21364)")
		UNAME_MACHINE=alphaev7 ;;
	    "EV7.9 (21364A)")
		UNAME_MACHINE=alphaev79 ;;
	esac
	# A Pn.n version is a patched version.
	# A Vn.n version is a released version.
	# A Tn.n version is a released field test version.
	# A Xn.n version is an unreleased experimental baselevel.
	# 1.2 uses "1.2" for uname -r.
	# 使用 sed 命令去除版本号开头的字母 "P", "V", "T" 或 "X"
	OSF_REL=`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
	GUESS=$UNAME_MACHINE-dec-osf$OSF_REL
	;;
	# 进入正题，x86_64-linux
	# 在 x86_64 架构的 Linux 系统上，通过编译并运行一段简单的 C 代码，检测当前系统的 CPU 架构和使用的 C 标准库 libc ABI 应用程序二进制接口，并将检测结果分别存储在 CPU 和 LIBCABI 变量中。最终将这些信息组合成一个字符串，存储在 GUESS 变量中，用于后续的软件构建和配置。
	# x86 的“x”代表不确定，x可以是3，4，5，6，x86只是个统称
    x86_64:Linux:*:*)
    # 现在执行完set_cc_for_build()后$CC_FOR_BUILD被设置为可用的编译器名称
	set_cc_for_build
	# 将 UNAME_MACHINE 变量的值（即 x86_64）赋值给 CPU 变量，作为 CPU 架构的初始值
	CPU=$UNAME_MACHINE
	# $LIBC存储的是系统的libc（c标准库）
	#  将 LIBC 赋值给 LIBCABI 变量，作为 libc ABI 的初始值。
	LIBCABI=$LIBC
	if test "$CC_FOR_BUILD" != no_compiler_found; then
		# 将 ABI 变量的初始值设置为 64，表示默认情况下是 64 位 ABI。
	    ABI=64
	    # 根据不同的宏定义设置 `ABI` 变量的值。
	    sed 's/^	    //' \<< EOF > "$dummy.c"
	    #ifdef __i386__
	    # 当编译器编译 32 位程序时，会自动定义 __i386__ 宏。这段代码通过检测 __i386__ 宏，可以判断当前编译的是否是 32 位程序。
	    ABI=x86
	    #else
	    #ifdef __ILP32__
	    # x86_64 架构下有一种特殊的 ABI 叫做 x32 ABI，它使用 32 位指针，可以减小程序体积并提高内存使用效率。当使用 x32 ABI 编译程序时，会定义 __ILP32__ 宏。这段代码通过检测 __ILP32__ 宏，可以判断当前使用的是否是 x32 ABI。
	    ABI=x32
	    #endif
	    #endif
		EOF
		# 同样的，得到的cc_set_abi是一个赋值语句：‘ABI=x86’
	    cc_set_abi=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`
	    # 执行提取出的 ABI 变量的赋值语句，将 ABI 变量设置为编译器预处理后得到的值。
	    eval "$cc_set_abi"
	    case $ABI in
		x86) CPU=i686 ;;
		x32) LIBCABI=${LIBC}x32 ;;
	    esac
	fi
	# i686-pc-linux-64
	GUESS=$CPU-pc-linux-$LIBCABI
	;;
```